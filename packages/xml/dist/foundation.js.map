{"version":3,"file":"foundation.js","sourceRoot":"","sources":["../src/foundation.ts"],"names":[],"mappings":"AAAA;;;;;;;;GAQG;AACH,MAAM,UAAU,aAAa,CAC3B,GAAa,EACb,GAAW,EACX,KAAoC;IAEpC,MAAM,OAAO,GAAG,GAAG,CAAC,eAAe,CAAC,GAAG,CAAC,eAAe,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC;IAC3E,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC;SAClB,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,KAAK,KAAK,IAAI,CAAC;SACtC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,EAAE,KAAM,CAAC,CAAC,CAAC;IAClE,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,YAAY,CAC1B,OAAgB,EAChB,KAAoC;IAEpC,MAAM,UAAU,GAAY,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACrD,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,EAAE;QAC9C,IAAI,KAAK,KAAK,IAAI;YAAE,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;;YAChD,UAAU,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;IACH,OAAO,UAAU,CAAC;AACpB,CAAC;AAED,MAAM,UAAU,yBAAyB,CACvC,OAAmC,EACnC,GAA8B;IAE9B,IAAI,CAAC,OAAO,IAAI,CAAC,GAAG;QAAE,OAAO,EAAE,CAAC;IAChC,OAAO,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,MAAM,CACxC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,KAAK,GAAG,CACnC,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,SAAS,CAAC,GAAW,EAAE,GAAY;IACjD,IAAI,SAAS,GAAG,EAAE,EAChB,MAAM,GAAG,EAAE,CAAC;IAEd,IAAI,CAAC,GAAG;QAAE,GAAG,GAAG,IAAI,CAAC;IACrB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,UAAU,IAAI;QACvC,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC;YAAE,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,GAAI,CAAC,MAAM,CAAC,CAAC;QAChE,SAAS,IAAI,MAAM,GAAG,GAAG,GAAG,IAAI,GAAG,OAAO,CAAC;QAC3C,IAAI,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC;YAAE,MAAM,IAAI,GAAG,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACtD,CAAC;AAED,MAAM,UAAU,oBAAoB,CAClC,MAAe,EACf,OAAe,EACf,SAAS,GAAG,CAAC;IAEb,MAAM,OAAO,GAAG,KAAK,GAAG,OAAO,GAAG,SAAS,CAAC;IAC5C,MAAM,KAAK,GAAG,MAAM,CAAC,aAAa,CAAC,YAAY,OAAO,UAAU,OAAO,IAAI,CAAC,CAAC;IAE7E,IAAI,CAAC,KAAK;QAAE,OAAO,OAAO,CAAC;;QACtB,OAAO,oBAAoB,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE,SAAS,CAAC,CAAC;AACjE,CAAC","sourcesContent":["/**\n * @since 0.0.1\n *\n * @param Document - doc where the Element should be created\n * @param string Tag - Tagname of the element\n * @param Record<string, string | null> - Attributes to be added to the created element\n *\n * @returns a new [[`tag`]] element owned by [[`doc`]].\n */\nexport function createElement(\n  doc: Document,\n  tag: string,\n  attrs: Record<string, string | null>\n): Element {\n  const element = doc.createElementNS(doc.documentElement.namespaceURI, tag);\n  Object.entries(attrs)\n    .filter(([_, value]) => value !== null)\n    .forEach(([name, value]) => element.setAttribute(name, value!));\n  return element;\n}\n\n/**\n * @since 0.0.1\n *\n * @param Element - element to be cloned\n * @params Record<string, string | null> - Attributes to be added\n *\n * @returns a clone of `element` with attributes set to values from `attrs`.\n */\nexport function cloneElement(\n  element: Element,\n  attrs: Record<string, string | null>\n): Element {\n  const newElement = <Element>element.cloneNode(false);\n  Object.entries(attrs).forEach(([name, value]) => {\n    if (value === null) newElement.removeAttribute(name);\n    else newElement.setAttribute(name, value);\n  });\n  return newElement;\n}\n\nexport function getChildElementsByTagName(\n  element: Element | null | undefined,\n  tag: string | null | undefined\n): Element[] {\n  if (!element || !tag) return [];\n  return Array.from(element.children).filter(\n    element => element.tagName === tag\n  );\n}\n\n/**\n * Format xml string in \"pretty print\" style and return as a string\n * @param xml - xml document as a string\n * @param tab - character to use as a tab\n * @returns string with pretty print formatting\n */\nexport function formatXml(xml: string, tab?: string): string {\n  let formatted = '',\n    indent = '';\n\n  if (!tab) tab = '\\t';\n  xml.split(/>\\s*</).forEach(function (node) {\n    if (node.match(/^\\/\\w/)) indent = indent.substring(tab!.length);\n    formatted += indent + '<' + node + '>\\r\\n';\n    if (node.match(/^<?\\w[^>]*[^/]$/)) indent += tab;\n  });\n  return formatted.substring(1, formatted.length - 3);\n}\n\nexport function getUniqueElementName(\n  parent: Element,\n  tagName: string,\n  iteration = 1\n): string {\n  const newName = 'new' + tagName + iteration;\n  const child = parent.querySelector(`:scope > ${tagName}[name=\"${newName}\"]`);\n\n  if (!child) return newName;\n  else return getUniqueElementName(parent, tagName, ++iteration);\n}\n"]}